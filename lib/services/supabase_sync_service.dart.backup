import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/saved_analysis.dart';
import '../models/fortune_reading.dart';
import '../models/calendar_event.dart';
import '../models/saju_chars.dart';
import '../services/openai_service.dart';
import 'storage_service.dart';
import 'supabase_service.dart';

/// 동기화 결과 상태
enum SyncStatus { success, failed, conflict, offline }

/// 동기화 결과
class SyncResult {
  final SyncStatus status;
  final String? message;
  final int? syncedCount;
  final int? failedCount;

  const SyncResult({
    required this.status,
    this.message,
    this.syncedCount,
    this.failedCount,
  });

  bool get isSuccess => status == SyncStatus.success;
}

/// Supabase 클라우드 동기화 서비스
class SupabaseSyncService {
  static SupabaseSyncService? _instance;
  static SupabaseSyncService get instance => _instance ??= SupabaseSyncService._();
  
  SupabaseSyncService._();

  SupabaseClient? get _client => SupabaseService.instance.client;
  bool _isSyncing = false;

  /// 현재 동기화 진행 중 여부
  bool get isSyncing => _isSyncing;

  /// 전체 데이터 동기화 (업로드 + 다운로드)
  Future<SyncResult> syncAllData({
    bool forceUpload = false,
    bool forceDownload = false,
  }) async {
    if (_isSyncing) {
      return const SyncResult(
        status: SyncStatus.failed,
        message: '이미 동기화가 진행 중입니다',
      );
    }

    try {
      _isSyncing = true;
      debugPrint('🔄 전체 데이터 동기화 시작...');

      // 로그인 상태 확인
      final user = _client.auth.currentUser;
      if (user == null) {
        return const SyncResult(
          status: SyncStatus.failed,
          message: '로그인이 필요합니다',
        );
      }

      // 네트워크 연결 확인
      final isConnected = await SupabaseService.instance.checkConnection();
      if (!isConnected) {
        return const SyncResult(
          status: SyncStatus.offline,
          message: '네트워크 연결을 확인해주세요',
        );
      }

      int totalSynced = 0;
      int totalFailed = 0;

      // 1. 사주 분석 데이터 동기화
      final analysisResult = await _syncSajuAnalyses(forceUpload, forceDownload);
      if (analysisResult.isSuccess) {
        totalSynced += analysisResult.syncedCount ?? 0;
      } else {
        totalFailed += analysisResult.failedCount ?? 0;
      }

      // 2. 운세 데이터 동기화
      final fortuneResult = await _syncFortuneReadings(forceUpload, forceDownload);
      if (fortuneResult.isSuccess) {
        totalSynced += fortuneResult.syncedCount ?? 0;
      } else {
        totalFailed += fortuneResult.failedCount ?? 0;
      }

      // 3. 캘린더 이벤트 동기화
      final calendarResult = await _syncCalendarEvents(forceUpload, forceDownload);
      if (calendarResult.isSuccess) {
        totalSynced += calendarResult.syncedCount ?? 0;
      } else {
        totalFailed += calendarResult.failedCount ?? 0;
      }

      debugPrint('✅ 전체 동기화 완료: 성공 $totalSynced개, 실패 $totalFailed개');

      return SyncResult(
        status: totalFailed == 0 ? SyncStatus.success : SyncStatus.failed,
        message: totalFailed == 0 
            ? '동기화가 완료되었습니다'
            : '일부 데이터 동기화에 실패했습니다',
        syncedCount: totalSynced,
        failedCount: totalFailed,
      );

    } catch (e) {
      debugPrint('❌ 전체 동기화 실패: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: '동기화 중 오류가 발생했습니다: $e',
      );
    } finally {
      _isSyncing = false;
    }
  }

  /// 사주 분석 데이터 동기화
  Future<SyncResult> _syncSajuAnalyses(bool forceUpload, bool forceDownload) async {
    try {
      debugPrint('📊 사주 분석 데이터 동기화 중...');
      
      final user = _client.auth.currentUser!;
      int syncedCount = 0;

      // 업로드: 로컬 → 클라우드
      if (forceUpload || await _shouldUploadData('saju_analyses')) {
        final localAnalyses = await StorageService.instance.getSavedAnalysisList();
        
        for (final analysis in localAnalyses) {
          try {
            await _uploadSajuAnalysis(user.id, analysis);
            syncedCount++;
            debugPrint('📤 사주 분석 업로드 완료: ${analysis.id}');
          } catch (e) {
            debugPrint('❌ 사주 분석 업로드 실패: ${analysis.id} - $e');
          }
        }
      }

      // 다운로드: 클라우드 → 로컬
      if (forceDownload || await _shouldDownloadData('saju_analyses')) {
        final response = await _client
            .from('saju_analyses')
            .select()
            .eq('user_id', user.id)
            .order('created_at', ascending: false);

        for (final data in response as List) {
          try {
            final analysis = _convertToSavedAnalysis(data);
            await StorageService.instance.saveAnalysis(analysis);
            syncedCount++;
            debugPrint('📥 사주 분석 다운로드 완료: ${analysis.id}');
          } catch (e) {
            debugPrint('❌ 사주 분석 다운로드 실패: ${data['id']} - $e');
          }
        }
      }

      return SyncResult(
        status: SyncStatus.success,
        syncedCount: syncedCount,
      );
    } catch (e) {
      debugPrint('❌ 사주 분석 동기화 실패: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: '사주 분석 동기화 실패: $e',
      );
    }
  }

  /// 운세 데이터 동기화
  Future<SyncResult> _syncFortuneReadings(bool forceUpload, bool forceDownload) async {
    try {
      debugPrint('🔮 운세 데이터 동기화 중...');
      
      final user = _client.auth.currentUser!;
      int syncedCount = 0;

      // 업로드: 로컬 → 클라우드
      if (forceUpload || await _shouldUploadData('fortune_readings')) {
        // 로컬 운세 히스토리를 가져와서 업로드
        final prefs = await StorageService.instance.preferences;
        final jsonList = prefs.getStringList('fortune_history') ?? [];
        
        for (final jsonStr in jsonList) {
          try {
            final json = jsonDecode(jsonStr);
            final fortune = FortuneReading.fromJson(json);
            await _uploadFortuneReading(user.id, fortune);
            syncedCount++;
            debugPrint('📤 운세 업로드 완료: ${fortune.id}');
          } catch (e) {
            debugPrint('❌ 운세 업로드 실패: $e');
          }
        }
      }

      // 다운로드: 클라우드 → 로컬
      if (forceDownload || await _shouldDownloadData('fortune_readings')) {
        final response = await _client
            .from('fortune_readings')
            .select()
            .eq('user_id', user.id)
            .order('created_at', ascending: false)
            .limit(50); // 최근 50개만

        final fortuneList = <FortuneReading>[];
        for (final data in response as List) {
          try {
            final fortune = _convertToFortuneReading(data);
            fortuneList.add(fortune);
            syncedCount++;
          } catch (e) {
            debugPrint('❌ 운세 데이터 변환 실패: ${data['id']} - $e');
          }
        }

        // 로컬에 저장
        if (fortuneList.isNotEmpty) {
          final prefs = await StorageService.instance.preferences;
          final jsonList = fortuneList.map((f) => jsonEncode(f.toJson())).toList();
          await prefs.setStringList('fortune_history', jsonList);
          debugPrint('📥 운세 다운로드 완료: ${fortuneList.length}개');
        }
      }

      return SyncResult(
        status: SyncStatus.success,
        syncedCount: syncedCount,
      );
    } catch (e) {
      debugPrint('❌ 운세 동기화 실패: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: '운세 동기화 실패: $e',
      );
    }
  }

  /// 캘린더 이벤트 동기화
  Future<SyncResult> _syncCalendarEvents(bool forceUpload, bool forceDownload) async {
    try {
      debugPrint('📅 캘린더 이벤트 동기화 중...');
      
      final user = _client.auth.currentUser!;
      int syncedCount = 0;

      // 업로드: 로컬 → 클라우드
      if (forceUpload || await _shouldUploadData('calendar_events')) {
        final localEvents = await StorageService.instance.getSavedGoodDayEvents();
        
        for (final event in localEvents) {
          try {
            await _uploadCalendarEvent(user.id, event);
            syncedCount++;
            debugPrint('📤 캘린더 이벤트 업로드 완료: ${event.id}');
          } catch (e) {
            debugPrint('❌ 캘린더 이벤트 업로드 실패: ${event.id} - $e');
          }
        }
      }

      // 다운로드: 클라우드 → 로컬
      if (forceDownload || await _shouldDownloadData('calendar_events')) {
        final response = await _client
            .from('calendar_events')
            .select()
            .eq('user_id', user.id)
            .order('event_date', ascending: false);

        final eventList = <CalendarEvent>[];
        for (final data in response as List) {
          try {
            final event = _convertToCalendarEvent(data);
            eventList.add(event);
            syncedCount++;
          } catch (e) {
            debugPrint('❌ 캘린더 이벤트 변환 실패: ${data['id']} - $e');
          }
        }

        // 로컬에 저장
        if (eventList.isNotEmpty) {
          await StorageService.instance.saveGoodDayEvents(eventList);
          debugPrint('📥 캘린더 이벤트 다운로드 완료: ${eventList.length}개');
        }
      }

      return SyncResult(
        status: SyncStatus.success,
        syncedCount: syncedCount,
      );
    } catch (e) {
      debugPrint('❌ 캘린더 이벤트 동기화 실패: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: '캘린더 이벤트 동기화 실패: $e',
      );
    }
  }

  /// 사주 분석을 Supabase에 업로드
  Future<void> _uploadSajuAnalysis(String userId, SavedAnalysis analysis) async {
    final data = {
      'id': analysis.id,
      'user_id': userId,
      'name': analysis.name,
      'birth_date': analysis.birthDate.toIso8601String().split('T')[0],
      'gender': analysis.gender,
      'is_lunar_calendar': analysis.isLunar,
      
      // 사주 8자
      'year_cheongan': analysis.sajuChars.year.cheongan.index,
      'year_jiji': analysis.sajuChars.year.jiji.index,
      'month_cheongan': analysis.sajuChars.month.cheongan.index,
      'month_jiji': analysis.sajuChars.month.jiji.index,
      'day_cheongan': analysis.sajuChars.day.cheongan.index,
      'day_jiji': analysis.sajuChars.day.jiji.index,
      'hour_cheongan': analysis.sajuChars.hour.cheongan.index,
      'hour_jiji': analysis.sajuChars.hour.jiji.index,
      
      // 분석 결과
      'personality': analysis.analysisResult.personality,
      'wealth_fortune': analysis.analysisResult.fortune.wealth,
      'career_fortune': analysis.analysisResult.fortune.career,
      'health_fortune': analysis.analysisResult.fortune.health,
      'love_fortune': analysis.analysisResult.fortune.love,
      'caution_period': analysis.analysisResult.cautionPeriod,
      'summary': analysis.analysisResult.summary,
      'is_current': true, // 가장 최신 분석으로 설정
    };

    await _client.from('saju_analyses').upsert(data);
  }

  /// 운세를 Supabase에 업로드
  Future<void> _uploadFortuneReading(String userId, FortuneReading fortune) async {
    final data = {
      'id': fortune.id,
      'user_id': userId,
      'fortune_type': fortune.type.name,
      'date_value': fortune.date.toIso8601String().split('T')[0],
      'title': fortune.title,
      'summary': fortune.summary,
      'description': fortune.description,
      'wealth_score': fortune.scores.wealth,
      'health_score': fortune.scores.health,
      'love_score': fortune.scores.love,
      'career_score': fortune.scores.career,
      'general_score': fortune.scores.general,
      'lucky_items': fortune.luckyItems,
      'recommendations': fortune.recommendations,
      'warnings': fortune.warnings,
      'is_favorite': fortune.isFavorite,
    };

    await _client.from('fortune_readings').upsert(data);
  }

  /// 캘린더 이벤트를 Supabase에 업로드
  Future<void> _uploadCalendarEvent(String userId, CalendarEvent event) async {
    final data = {
      'id': event.id,
      'user_id': userId,
      'title': event.title,
      'description': event.description,
      'event_date': event.date.toIso8601String().split('T')[0],
      'event_type': event.type.toString().split('.').last,
      'is_reminder_set': event.isReminderSet,
      'reminder_date': event.reminderDate?.toIso8601String(),
    };

    await _client.from('calendar_events').upsert(data);
  }

  /// Supabase 데이터를 SavedAnalysis로 변환
  SavedAnalysis _convertToSavedAnalysis(Map<String, dynamic> data) {
    // 사주 8자 복원
    final sajuChars = SajuChars(
      year: Ju(
        cheongan: Cheongan.fromIndex(data['year_cheongan']),
        jiji: Jiji.fromIndex(data['year_jiji']),
      ),
      month: Ju(
        cheongan: Cheongan.fromIndex(data['month_cheongan']),
        jiji: Jiji.fromIndex(data['month_jiji']),
      ),
      day: Ju(
        cheongan: Cheongan.fromIndex(data['day_cheongan']),
        jiji: Jiji.fromIndex(data['day_jiji']),
      ),
      hour: Ju(
        cheongan: Cheongan.fromIndex(data['hour_cheongan']),
        jiji: Jiji.fromIndex(data['hour_jiji']),
      ),
    );

    // 분석 결과 복원
    final analysisResult = SajuAnalysisResult(
      personality: data['personality'] ?? '',
      fortune: Fortune(
        wealth: data['wealth_fortune'] ?? '',
        career: data['career_fortune'] ?? '',
        health: data['health_fortune'] ?? '',
        love: data['love_fortune'] ?? '',
      ),
      cautionPeriod: data['caution_period'] ?? '',
      goodDays: [], // 별도 테이블에서 로드
      summary: data['summary'] ?? '',
    );

    return SavedAnalysis(
      id: data['id'],
      name: data['name'],
      birthDate: DateTime.parse(data['birth_date']),
      gender: data['gender'],
      isLunar: data['is_lunar_calendar'] ?? false,
      sajuChars: sajuChars,
      analysisResult: analysisResult,
      goodDayEvents: [], // 별도 테이블에서 로드
      createdAt: DateTime.parse(data['created_at']),
      updatedAt: DateTime.parse(data['updated_at']),
    );
  }

  /// Supabase 데이터를 FortuneReading으로 변환
  FortuneReading _convertToFortuneReading(Map<String, dynamic> data) {
    return FortuneReading(
      id: data['id'],
      type: FortuneType.values.firstWhere(
        (e) => e.name == data['fortune_type'],
        orElse: () => FortuneType.daily,
      ),
      date: DateTime.parse(data['date_value']),
      title: data['title'],
      summary: data['summary'],
      description: data['description'],
      scores: FortuneScores(
        wealth: data['wealth_score'] ?? 50,
        health: data['health_score'] ?? 50,
        love: data['love_score'] ?? 50,
        career: data['career_score'] ?? 50,
        general: data['general_score'] ?? 50,
      ),
      luckyItems: List<String>.from(data['lucky_items'] ?? []),
      recommendations: List<String>.from(data['recommendations'] ?? []),
      warnings: List<String>.from(data['warnings'] ?? []),
      createdAt: DateTime.parse(data['created_at']),
      isFavorite: data['is_favorite'] ?? false,
    );
  }

  /// Supabase 데이터를 CalendarEvent로 변환
  CalendarEvent _convertToCalendarEvent(Map<String, dynamic> data) {
    return CalendarEvent(
      id: data['id'],
      date: DateTime.parse(data['event_date']),
      title: data['title'],
      description: data['description'] ?? '',
      type: CalendarEventType.values.firstWhere(
        (e) => e.toString().split('.').last == data['event_type'],
        orElse: () => CalendarEventType.general,
      ),
      isReminderSet: data['is_reminder_set'] ?? false,
      reminderDate: data['reminder_date'] != null 
          ? DateTime.parse(data['reminder_date'])
          : null,
    );
  }

  /// 업로드가 필요한지 확인
  Future<bool> _shouldUploadData(String tableName) async {
    try {
      final prefs = await StorageService.instance.preferences;
      final lastSync = prefs.getString('last_upload_$tableName');
      
      if (lastSync == null) return true;
      
      final lastSyncTime = DateTime.parse(lastSync);
      final now = DateTime.now();
      
      // 24시간마다 동기화
      return now.difference(lastSyncTime).inHours >= 24;
    } catch (e) {
      return true; // 오류 시 업로드 수행
    }
  }

  /// 다운로드가 필요한지 확인
  Future<bool> _shouldDownloadData(String tableName) async {
    try {
      final prefs = await StorageService.instance.preferences;
      final lastSync = prefs.getString('last_download_$tableName');
      
      if (lastSync == null) return true;
      
      final lastSyncTime = DateTime.parse(lastSync);
      final now = DateTime.now();
      
      // 12시간마다 동기화
      return now.difference(lastSyncTime).inHours >= 12;
    } catch (e) {
      return true; // 오류 시 다운로드 수행
    }
  }

  /// 동기화 시간 기록
  Future<void> _recordSyncTime(String operation, String tableName) async {
    try {
      final prefs = await StorageService.instance.preferences;
      await prefs.setString('${operation}_$tableName', DateTime.now().toIso8601String());
    } catch (e) {
      debugPrint('❌ 동기화 시간 기록 실패: $e');
    }
  }

  /// 클라우드 백업 생성
  Future<SyncResult> createBackup() async {
    try {
      debugPrint('💾 클라우드 백업 생성 중...');
      
      final result = await syncAllData(forceUpload: true);
      
      if (result.isSuccess) {
        final prefs = await StorageService.instance.preferences;
        await prefs.setString('last_backup', DateTime.now().toIso8601String());
        
        return const SyncResult(
          status: SyncStatus.success,
          message: '백업이 완료되었습니다',
        );
      }
      
      return result;
    } catch (e) {
      debugPrint('❌ 백업 생성 실패: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: '백업 생성 실패: $e',
      );
    }
  }

  /// 클라우드에서 복원
  Future<SyncResult> restoreFromCloud() async {
    try {
      debugPrint('📥 클라우드에서 복원 중...');
      
      final result = await syncAllData(forceDownload: true);
      
      if (result.isSuccess) {
        return const SyncResult(
          status: SyncStatus.success,
          message: '데이터 복원이 완료되었습니다',
        );
      }
      
      return result;
    } catch (e) {
      debugPrint('❌ 복원 실패: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: '데이터 복원 실패: $e',
      );
    }
  }

  /// 마지막 동기화 시간 가져오기
  Future<DateTime?> getLastSyncTime() async {
    try {
      final prefs = await StorageService.instance.preferences;
      final lastSyncStr = prefs.getString('last_full_sync');
      return lastSyncStr != null ? DateTime.parse(lastSyncStr) : null;
    } catch (e) {
      return null;
    }
  }
} 