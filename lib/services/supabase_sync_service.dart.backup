import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/saved_analysis.dart';
import '../models/fortune_reading.dart';
import '../models/calendar_event.dart';
import '../models/saju_chars.dart';
import '../services/openai_service.dart';
import 'storage_service.dart';
import 'supabase_service.dart';

/// ë™ê¸°í™” ê²°ê³¼ ìƒíƒœ
enum SyncStatus { success, failed, conflict, offline }

/// ë™ê¸°í™” ê²°ê³¼
class SyncResult {
  final SyncStatus status;
  final String? message;
  final int? syncedCount;
  final int? failedCount;

  const SyncResult({
    required this.status,
    this.message,
    this.syncedCount,
    this.failedCount,
  });

  bool get isSuccess => status == SyncStatus.success;
}

/// Supabase í´ë¼ìš°ë“œ ë™ê¸°í™” ì„œë¹„ìŠ¤
class SupabaseSyncService {
  static SupabaseSyncService? _instance;
  static SupabaseSyncService get instance => _instance ??= SupabaseSyncService._();
  
  SupabaseSyncService._();

  SupabaseClient? get _client => SupabaseService.instance.client;
  bool _isSyncing = false;

  /// í˜„ì¬ ë™ê¸°í™” ì§„í–‰ ì¤‘ ì—¬ë¶€
  bool get isSyncing => _isSyncing;

  /// ì „ì²´ ë°ì´í„° ë™ê¸°í™” (ì—…ë¡œë“œ + ë‹¤ìš´ë¡œë“œ)
  Future<SyncResult> syncAllData({
    bool forceUpload = false,
    bool forceDownload = false,
  }) async {
    if (_isSyncing) {
      return const SyncResult(
        status: SyncStatus.failed,
        message: 'ì´ë¯¸ ë™ê¸°í™”ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤',
      );
    }

    try {
      _isSyncing = true;
      debugPrint('ğŸ”„ ì „ì²´ ë°ì´í„° ë™ê¸°í™” ì‹œì‘...');

      // ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸
      final user = _client.auth.currentUser;
      if (user == null) {
        return const SyncResult(
          status: SyncStatus.failed,
          message: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤',
        );
      }

      // ë„¤íŠ¸ì›Œí¬ ì—°ê²° í™•ì¸
      final isConnected = await SupabaseService.instance.checkConnection();
      if (!isConnected) {
        return const SyncResult(
          status: SyncStatus.offline,
          message: 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”',
        );
      }

      int totalSynced = 0;
      int totalFailed = 0;

      // 1. ì‚¬ì£¼ ë¶„ì„ ë°ì´í„° ë™ê¸°í™”
      final analysisResult = await _syncSajuAnalyses(forceUpload, forceDownload);
      if (analysisResult.isSuccess) {
        totalSynced += analysisResult.syncedCount ?? 0;
      } else {
        totalFailed += analysisResult.failedCount ?? 0;
      }

      // 2. ìš´ì„¸ ë°ì´í„° ë™ê¸°í™”
      final fortuneResult = await _syncFortuneReadings(forceUpload, forceDownload);
      if (fortuneResult.isSuccess) {
        totalSynced += fortuneResult.syncedCount ?? 0;
      } else {
        totalFailed += fortuneResult.failedCount ?? 0;
      }

      // 3. ìº˜ë¦°ë” ì´ë²¤íŠ¸ ë™ê¸°í™”
      final calendarResult = await _syncCalendarEvents(forceUpload, forceDownload);
      if (calendarResult.isSuccess) {
        totalSynced += calendarResult.syncedCount ?? 0;
      } else {
        totalFailed += calendarResult.failedCount ?? 0;
      }

      debugPrint('âœ… ì „ì²´ ë™ê¸°í™” ì™„ë£Œ: ì„±ê³µ $totalSyncedê°œ, ì‹¤íŒ¨ $totalFailedê°œ');

      return SyncResult(
        status: totalFailed == 0 ? SyncStatus.success : SyncStatus.failed,
        message: totalFailed == 0 
            ? 'ë™ê¸°í™”ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤'
            : 'ì¼ë¶€ ë°ì´í„° ë™ê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤',
        syncedCount: totalSynced,
        failedCount: totalFailed,
      );

    } catch (e) {
      debugPrint('âŒ ì „ì²´ ë™ê¸°í™” ì‹¤íŒ¨: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: 'ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: $e',
      );
    } finally {
      _isSyncing = false;
    }
  }

  /// ì‚¬ì£¼ ë¶„ì„ ë°ì´í„° ë™ê¸°í™”
  Future<SyncResult> _syncSajuAnalyses(bool forceUpload, bool forceDownload) async {
    try {
      debugPrint('ğŸ“Š ì‚¬ì£¼ ë¶„ì„ ë°ì´í„° ë™ê¸°í™” ì¤‘...');
      
      final user = _client.auth.currentUser!;
      int syncedCount = 0;

      // ì—…ë¡œë“œ: ë¡œì»¬ â†’ í´ë¼ìš°ë“œ
      if (forceUpload || await _shouldUploadData('saju_analyses')) {
        final localAnalyses = await StorageService.instance.getSavedAnalysisList();
        
        for (final analysis in localAnalyses) {
          try {
            await _uploadSajuAnalysis(user.id, analysis);
            syncedCount++;
            debugPrint('ğŸ“¤ ì‚¬ì£¼ ë¶„ì„ ì—…ë¡œë“œ ì™„ë£Œ: ${analysis.id}');
          } catch (e) {
            debugPrint('âŒ ì‚¬ì£¼ ë¶„ì„ ì—…ë¡œë“œ ì‹¤íŒ¨: ${analysis.id} - $e');
          }
        }
      }

      // ë‹¤ìš´ë¡œë“œ: í´ë¼ìš°ë“œ â†’ ë¡œì»¬
      if (forceDownload || await _shouldDownloadData('saju_analyses')) {
        final response = await _client
            .from('saju_analyses')
            .select()
            .eq('user_id', user.id)
            .order('created_at', ascending: false);

        for (final data in response as List) {
          try {
            final analysis = _convertToSavedAnalysis(data);
            await StorageService.instance.saveAnalysis(analysis);
            syncedCount++;
            debugPrint('ğŸ“¥ ì‚¬ì£¼ ë¶„ì„ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ: ${analysis.id}');
          } catch (e) {
            debugPrint('âŒ ì‚¬ì£¼ ë¶„ì„ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ${data['id']} - $e');
          }
        }
      }

      return SyncResult(
        status: SyncStatus.success,
        syncedCount: syncedCount,
      );
    } catch (e) {
      debugPrint('âŒ ì‚¬ì£¼ ë¶„ì„ ë™ê¸°í™” ì‹¤íŒ¨: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: 'ì‚¬ì£¼ ë¶„ì„ ë™ê¸°í™” ì‹¤íŒ¨: $e',
      );
    }
  }

  /// ìš´ì„¸ ë°ì´í„° ë™ê¸°í™”
  Future<SyncResult> _syncFortuneReadings(bool forceUpload, bool forceDownload) async {
    try {
      debugPrint('ğŸ”® ìš´ì„¸ ë°ì´í„° ë™ê¸°í™” ì¤‘...');
      
      final user = _client.auth.currentUser!;
      int syncedCount = 0;

      // ì—…ë¡œë“œ: ë¡œì»¬ â†’ í´ë¼ìš°ë“œ
      if (forceUpload || await _shouldUploadData('fortune_readings')) {
        // ë¡œì»¬ ìš´ì„¸ íˆìŠ¤í† ë¦¬ë¥¼ ê°€ì ¸ì™€ì„œ ì—…ë¡œë“œ
        final prefs = await StorageService.instance.preferences;
        final jsonList = prefs.getStringList('fortune_history') ?? [];
        
        for (final jsonStr in jsonList) {
          try {
            final json = jsonDecode(jsonStr);
            final fortune = FortuneReading.fromJson(json);
            await _uploadFortuneReading(user.id, fortune);
            syncedCount++;
            debugPrint('ğŸ“¤ ìš´ì„¸ ì—…ë¡œë“œ ì™„ë£Œ: ${fortune.id}');
          } catch (e) {
            debugPrint('âŒ ìš´ì„¸ ì—…ë¡œë“œ ì‹¤íŒ¨: $e');
          }
        }
      }

      // ë‹¤ìš´ë¡œë“œ: í´ë¼ìš°ë“œ â†’ ë¡œì»¬
      if (forceDownload || await _shouldDownloadData('fortune_readings')) {
        final response = await _client
            .from('fortune_readings')
            .select()
            .eq('user_id', user.id)
            .order('created_at', ascending: false)
            .limit(50); // ìµœê·¼ 50ê°œë§Œ

        final fortuneList = <FortuneReading>[];
        for (final data in response as List) {
          try {
            final fortune = _convertToFortuneReading(data);
            fortuneList.add(fortune);
            syncedCount++;
          } catch (e) {
            debugPrint('âŒ ìš´ì„¸ ë°ì´í„° ë³€í™˜ ì‹¤íŒ¨: ${data['id']} - $e');
          }
        }

        // ë¡œì»¬ì— ì €ì¥
        if (fortuneList.isNotEmpty) {
          final prefs = await StorageService.instance.preferences;
          final jsonList = fortuneList.map((f) => jsonEncode(f.toJson())).toList();
          await prefs.setStringList('fortune_history', jsonList);
          debugPrint('ğŸ“¥ ìš´ì„¸ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ: ${fortuneList.length}ê°œ');
        }
      }

      return SyncResult(
        status: SyncStatus.success,
        syncedCount: syncedCount,
      );
    } catch (e) {
      debugPrint('âŒ ìš´ì„¸ ë™ê¸°í™” ì‹¤íŒ¨: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: 'ìš´ì„¸ ë™ê¸°í™” ì‹¤íŒ¨: $e',
      );
    }
  }

  /// ìº˜ë¦°ë” ì´ë²¤íŠ¸ ë™ê¸°í™”
  Future<SyncResult> _syncCalendarEvents(bool forceUpload, bool forceDownload) async {
    try {
      debugPrint('ğŸ“… ìº˜ë¦°ë” ì´ë²¤íŠ¸ ë™ê¸°í™” ì¤‘...');
      
      final user = _client.auth.currentUser!;
      int syncedCount = 0;

      // ì—…ë¡œë“œ: ë¡œì»¬ â†’ í´ë¼ìš°ë“œ
      if (forceUpload || await _shouldUploadData('calendar_events')) {
        final localEvents = await StorageService.instance.getSavedGoodDayEvents();
        
        for (final event in localEvents) {
          try {
            await _uploadCalendarEvent(user.id, event);
            syncedCount++;
            debugPrint('ğŸ“¤ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ì—…ë¡œë“œ ì™„ë£Œ: ${event.id}');
          } catch (e) {
            debugPrint('âŒ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ì—…ë¡œë“œ ì‹¤íŒ¨: ${event.id} - $e');
          }
        }
      }

      // ë‹¤ìš´ë¡œë“œ: í´ë¼ìš°ë“œ â†’ ë¡œì»¬
      if (forceDownload || await _shouldDownloadData('calendar_events')) {
        final response = await _client
            .from('calendar_events')
            .select()
            .eq('user_id', user.id)
            .order('event_date', ascending: false);

        final eventList = <CalendarEvent>[];
        for (final data in response as List) {
          try {
            final event = _convertToCalendarEvent(data);
            eventList.add(event);
            syncedCount++;
          } catch (e) {
            debugPrint('âŒ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ë³€í™˜ ì‹¤íŒ¨: ${data['id']} - $e');
          }
        }

        // ë¡œì»¬ì— ì €ì¥
        if (eventList.isNotEmpty) {
          await StorageService.instance.saveGoodDayEvents(eventList);
          debugPrint('ğŸ“¥ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ: ${eventList.length}ê°œ');
        }
      }

      return SyncResult(
        status: SyncStatus.success,
        syncedCount: syncedCount,
      );
    } catch (e) {
      debugPrint('âŒ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ë™ê¸°í™” ì‹¤íŒ¨: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: 'ìº˜ë¦°ë” ì´ë²¤íŠ¸ ë™ê¸°í™” ì‹¤íŒ¨: $e',
      );
    }
  }

  /// ì‚¬ì£¼ ë¶„ì„ì„ Supabaseì— ì—…ë¡œë“œ
  Future<void> _uploadSajuAnalysis(String userId, SavedAnalysis analysis) async {
    final data = {
      'id': analysis.id,
      'user_id': userId,
      'name': analysis.name,
      'birth_date': analysis.birthDate.toIso8601String().split('T')[0],
      'gender': analysis.gender,
      'is_lunar_calendar': analysis.isLunar,
      
      // ì‚¬ì£¼ 8ì
      'year_cheongan': analysis.sajuChars.year.cheongan.index,
      'year_jiji': analysis.sajuChars.year.jiji.index,
      'month_cheongan': analysis.sajuChars.month.cheongan.index,
      'month_jiji': analysis.sajuChars.month.jiji.index,
      'day_cheongan': analysis.sajuChars.day.cheongan.index,
      'day_jiji': analysis.sajuChars.day.jiji.index,
      'hour_cheongan': analysis.sajuChars.hour.cheongan.index,
      'hour_jiji': analysis.sajuChars.hour.jiji.index,
      
      // ë¶„ì„ ê²°ê³¼
      'personality': analysis.analysisResult.personality,
      'wealth_fortune': analysis.analysisResult.fortune.wealth,
      'career_fortune': analysis.analysisResult.fortune.career,
      'health_fortune': analysis.analysisResult.fortune.health,
      'love_fortune': analysis.analysisResult.fortune.love,
      'caution_period': analysis.analysisResult.cautionPeriod,
      'summary': analysis.analysisResult.summary,
      'is_current': true, // ê°€ì¥ ìµœì‹  ë¶„ì„ìœ¼ë¡œ ì„¤ì •
    };

    await _client.from('saju_analyses').upsert(data);
  }

  /// ìš´ì„¸ë¥¼ Supabaseì— ì—…ë¡œë“œ
  Future<void> _uploadFortuneReading(String userId, FortuneReading fortune) async {
    final data = {
      'id': fortune.id,
      'user_id': userId,
      'fortune_type': fortune.type.name,
      'date_value': fortune.date.toIso8601String().split('T')[0],
      'title': fortune.title,
      'summary': fortune.summary,
      'description': fortune.description,
      'wealth_score': fortune.scores.wealth,
      'health_score': fortune.scores.health,
      'love_score': fortune.scores.love,
      'career_score': fortune.scores.career,
      'general_score': fortune.scores.general,
      'lucky_items': fortune.luckyItems,
      'recommendations': fortune.recommendations,
      'warnings': fortune.warnings,
      'is_favorite': fortune.isFavorite,
    };

    await _client.from('fortune_readings').upsert(data);
  }

  /// ìº˜ë¦°ë” ì´ë²¤íŠ¸ë¥¼ Supabaseì— ì—…ë¡œë“œ
  Future<void> _uploadCalendarEvent(String userId, CalendarEvent event) async {
    final data = {
      'id': event.id,
      'user_id': userId,
      'title': event.title,
      'description': event.description,
      'event_date': event.date.toIso8601String().split('T')[0],
      'event_type': event.type.toString().split('.').last,
      'is_reminder_set': event.isReminderSet,
      'reminder_date': event.reminderDate?.toIso8601String(),
    };

    await _client.from('calendar_events').upsert(data);
  }

  /// Supabase ë°ì´í„°ë¥¼ SavedAnalysisë¡œ ë³€í™˜
  SavedAnalysis _convertToSavedAnalysis(Map<String, dynamic> data) {
    // ì‚¬ì£¼ 8ì ë³µì›
    final sajuChars = SajuChars(
      year: Ju(
        cheongan: Cheongan.fromIndex(data['year_cheongan']),
        jiji: Jiji.fromIndex(data['year_jiji']),
      ),
      month: Ju(
        cheongan: Cheongan.fromIndex(data['month_cheongan']),
        jiji: Jiji.fromIndex(data['month_jiji']),
      ),
      day: Ju(
        cheongan: Cheongan.fromIndex(data['day_cheongan']),
        jiji: Jiji.fromIndex(data['day_jiji']),
      ),
      hour: Ju(
        cheongan: Cheongan.fromIndex(data['hour_cheongan']),
        jiji: Jiji.fromIndex(data['hour_jiji']),
      ),
    );

    // ë¶„ì„ ê²°ê³¼ ë³µì›
    final analysisResult = SajuAnalysisResult(
      personality: data['personality'] ?? '',
      fortune: Fortune(
        wealth: data['wealth_fortune'] ?? '',
        career: data['career_fortune'] ?? '',
        health: data['health_fortune'] ?? '',
        love: data['love_fortune'] ?? '',
      ),
      cautionPeriod: data['caution_period'] ?? '',
      goodDays: [], // ë³„ë„ í…Œì´ë¸”ì—ì„œ ë¡œë“œ
      summary: data['summary'] ?? '',
    );

    return SavedAnalysis(
      id: data['id'],
      name: data['name'],
      birthDate: DateTime.parse(data['birth_date']),
      gender: data['gender'],
      isLunar: data['is_lunar_calendar'] ?? false,
      sajuChars: sajuChars,
      analysisResult: analysisResult,
      goodDayEvents: [], // ë³„ë„ í…Œì´ë¸”ì—ì„œ ë¡œë“œ
      createdAt: DateTime.parse(data['created_at']),
      updatedAt: DateTime.parse(data['updated_at']),
    );
  }

  /// Supabase ë°ì´í„°ë¥¼ FortuneReadingìœ¼ë¡œ ë³€í™˜
  FortuneReading _convertToFortuneReading(Map<String, dynamic> data) {
    return FortuneReading(
      id: data['id'],
      type: FortuneType.values.firstWhere(
        (e) => e.name == data['fortune_type'],
        orElse: () => FortuneType.daily,
      ),
      date: DateTime.parse(data['date_value']),
      title: data['title'],
      summary: data['summary'],
      description: data['description'],
      scores: FortuneScores(
        wealth: data['wealth_score'] ?? 50,
        health: data['health_score'] ?? 50,
        love: data['love_score'] ?? 50,
        career: data['career_score'] ?? 50,
        general: data['general_score'] ?? 50,
      ),
      luckyItems: List<String>.from(data['lucky_items'] ?? []),
      recommendations: List<String>.from(data['recommendations'] ?? []),
      warnings: List<String>.from(data['warnings'] ?? []),
      createdAt: DateTime.parse(data['created_at']),
      isFavorite: data['is_favorite'] ?? false,
    );
  }

  /// Supabase ë°ì´í„°ë¥¼ CalendarEventë¡œ ë³€í™˜
  CalendarEvent _convertToCalendarEvent(Map<String, dynamic> data) {
    return CalendarEvent(
      id: data['id'],
      date: DateTime.parse(data['event_date']),
      title: data['title'],
      description: data['description'] ?? '',
      type: CalendarEventType.values.firstWhere(
        (e) => e.toString().split('.').last == data['event_type'],
        orElse: () => CalendarEventType.general,
      ),
      isReminderSet: data['is_reminder_set'] ?? false,
      reminderDate: data['reminder_date'] != null 
          ? DateTime.parse(data['reminder_date'])
          : null,
    );
  }

  /// ì—…ë¡œë“œê°€ í•„ìš”í•œì§€ í™•ì¸
  Future<bool> _shouldUploadData(String tableName) async {
    try {
      final prefs = await StorageService.instance.preferences;
      final lastSync = prefs.getString('last_upload_$tableName');
      
      if (lastSync == null) return true;
      
      final lastSyncTime = DateTime.parse(lastSync);
      final now = DateTime.now();
      
      // 24ì‹œê°„ë§ˆë‹¤ ë™ê¸°í™”
      return now.difference(lastSyncTime).inHours >= 24;
    } catch (e) {
      return true; // ì˜¤ë¥˜ ì‹œ ì—…ë¡œë“œ ìˆ˜í–‰
    }
  }

  /// ë‹¤ìš´ë¡œë“œê°€ í•„ìš”í•œì§€ í™•ì¸
  Future<bool> _shouldDownloadData(String tableName) async {
    try {
      final prefs = await StorageService.instance.preferences;
      final lastSync = prefs.getString('last_download_$tableName');
      
      if (lastSync == null) return true;
      
      final lastSyncTime = DateTime.parse(lastSync);
      final now = DateTime.now();
      
      // 12ì‹œê°„ë§ˆë‹¤ ë™ê¸°í™”
      return now.difference(lastSyncTime).inHours >= 12;
    } catch (e) {
      return true; // ì˜¤ë¥˜ ì‹œ ë‹¤ìš´ë¡œë“œ ìˆ˜í–‰
    }
  }

  /// ë™ê¸°í™” ì‹œê°„ ê¸°ë¡
  Future<void> _recordSyncTime(String operation, String tableName) async {
    try {
      final prefs = await StorageService.instance.preferences;
      await prefs.setString('${operation}_$tableName', DateTime.now().toIso8601String());
    } catch (e) {
      debugPrint('âŒ ë™ê¸°í™” ì‹œê°„ ê¸°ë¡ ì‹¤íŒ¨: $e');
    }
  }

  /// í´ë¼ìš°ë“œ ë°±ì—… ìƒì„±
  Future<SyncResult> createBackup() async {
    try {
      debugPrint('ğŸ’¾ í´ë¼ìš°ë“œ ë°±ì—… ìƒì„± ì¤‘...');
      
      final result = await syncAllData(forceUpload: true);
      
      if (result.isSuccess) {
        final prefs = await StorageService.instance.preferences;
        await prefs.setString('last_backup', DateTime.now().toIso8601String());
        
        return const SyncResult(
          status: SyncStatus.success,
          message: 'ë°±ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤',
        );
      }
      
      return result;
    } catch (e) {
      debugPrint('âŒ ë°±ì—… ìƒì„± ì‹¤íŒ¨: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: 'ë°±ì—… ìƒì„± ì‹¤íŒ¨: $e',
      );
    }
  }

  /// í´ë¼ìš°ë“œì—ì„œ ë³µì›
  Future<SyncResult> restoreFromCloud() async {
    try {
      debugPrint('ğŸ“¥ í´ë¼ìš°ë“œì—ì„œ ë³µì› ì¤‘...');
      
      final result = await syncAllData(forceDownload: true);
      
      if (result.isSuccess) {
        return const SyncResult(
          status: SyncStatus.success,
          message: 'ë°ì´í„° ë³µì›ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤',
        );
      }
      
      return result;
    } catch (e) {
      debugPrint('âŒ ë³µì› ì‹¤íŒ¨: $e');
      return SyncResult(
        status: SyncStatus.failed,
        message: 'ë°ì´í„° ë³µì› ì‹¤íŒ¨: $e',
      );
    }
  }

  /// ë§ˆì§€ë§‰ ë™ê¸°í™” ì‹œê°„ ê°€ì ¸ì˜¤ê¸°
  Future<DateTime?> getLastSyncTime() async {
    try {
      final prefs = await StorageService.instance.preferences;
      final lastSyncStr = prefs.getString('last_full_sync');
      return lastSyncStr != null ? DateTime.parse(lastSyncStr) : null;
    } catch (e) {
      return null;
    }
  }
} 